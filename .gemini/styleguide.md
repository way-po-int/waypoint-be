# 코드 리뷰 가이드

## 1. 리뷰 우선순위 및 형식

리뷰 시 아래 우선순위에 따라 중요도를 판단하고, 지정된 형식을 사용해줘.

- **언어**: 모든 코드 리뷰는 **한국어**로 작성해줘.
- **수정 제안**: 구체적인 코드 수정이 필요할 경우 반드시 GitHub의 **`Suggested changes`** 기능을 사용해줘.
- **논리적 근거**: 새로운 코드를 제안하거나 수정을 요청할 때는 **"왜(Why)" 그렇게 해야 하는지** 이유를 설명해줘. (예: 성능 최적화, 가독성 향상, 메모리 누수 방지 등)
- **중요도별 머리말 태그**: 리뷰의 성격에 따라 아래 태그 중 하나를 선택해 댓글 첫 줄에 달아줘.

    - 🚨 **[Critical]**:
        - **대상**: 런타임 오류(NPE, 무한 루프), 보안 취약점, 데이터 부정합(트랜잭션 누락), 아키텍처 원칙 위반(도메인 오염).
        - **가이드**: "시스템이 터지거나 데이터가 꼬일 수 있는" 치명적인 결함이야. 단순히 "고치세요"가 아니라, 이 코드가 머지되었을 때 발생할 구체적인 장애 시나리오를 들어 수정의 시급성을
          설명해줘.

    - ✨ **[Suggestion]**:
        - **대상**: 코딩 컨벤션 위반, 가독성 저해, 중복 코드, 성능 최적화, 유지보수성 향상 제안.
        - **가이드**: 당장 장애는 없지만, 코드 품질과 미래의 유지보수성을 위해 개선이 필요한 사항이야. 수정 시 얻을 수 있는 이점을 함께 설명해줘.

    - 💡 **[Note]**:
        - **대상**: 개인적인 스타일 제안, 가벼운 질문, 그리고 훌륭하게 작성된 로직에 대한 격려.
        - **가이드**: "개발자의 성향이나 사소한 습관"에 관한 이야기야. 억지로 강요하기보다는 "이런 방법도 있어요" 정도로 가볍게 언급하고, 특히 좋은 코드에는 구체적인 칭찬을 아끼지 마.

## 2. 아키텍처 및 폴더 구조 규칙

우리 프로젝트는 DDD(Domain-Driven Design) 기반의 계층화 아키텍처를 따라. 각 패키지의 책임을 확인하고 위반 시 지적해줘.

- presentation: Controller, 요청/응답 DTO. 로직 없이 입출력 유효성 검증만 담당.
- application: Service, Command/Query DTO. 유스케이스 흐름 제어 및 트랜잭션 경계.
- domain: Entity, VO, Aggregate Root, Repository 인터페이스. 핵심 비즈니스 로직 응집. 외부 의존성 철저히 배제.
- infrastructure: Repository 구현체(Jpa, Querydsl 등), 외부 API 클라이언트 등 기술적 세부사항.
- error: ErrorCode 등 예외 관리.

## 3. 코딩 컨벤션

[네이버 캠퍼스 핵데이 Java 코딩 컨벤션](https://naver.github.io/hackday-conventions-java/)을 따르며, 특히 아래 사항을 집중적으로 리뷰해줘.

- **패키지 명명 (Package Naming)**:
    - 패키지 이름은 **모두 소문자**로 작성한다.
    - 단어 구분을 위한 **언더스코어(`_`)나 대시(`-`)를 사용하지 않고** 모든 단어를 붙여서 쓴다. (예: `com.navercorp.api_gateway` (X) ->
      `com.navercorp.apigateway` (O))
- **명명 규칙 (Naming)**:
    - 클래스는 **PascalCase**, 메서드와 변수는 **camelCase**를 사용한다.
    - 상수는 **UPPER_SNAKE_CASE**를 사용한다.
- **클래스 멤버 배치 순서**:
    - 클래스 내부 요소는 `static 변수 -> 인스턴스 변수 -> 생성자 -> 메서드` 순으로 배치한다.
    - 메서드 배치는 공개 메서드(`public`)를 우선 배치하고, 그 메서드에서 호출하는 프라이빗 메서드(`private`)를 바로 뒤에 배치하여 **신문 기사처럼 위에서 아래로 읽히게** 구성한다.
- **중괄호 및 공백**:
    - **K&R 스타일**을 준수하며, 빈 블록이라도 중괄호를 생략하지 않는다.
    - `if`, `for`, `while` 등 키워드와 여는 소괄호(`(`) 사이에는 반드시 **공백**을 삽입한다.
- **코드 현대화 및 Deprecated API 대응**:
    - **대체안 제시 (Prescriptive Guidance)**: 더 이상 권장되지 않는(`@Deprecated`) 메서드나 클래스를 발견하면, 단순히 지적하는 데 그치지 말고 이를 대체할 수 있는 **최신
      API나 표준 패턴**을 구체적인 코드 예시와 함께 추천해줘.
    - **장애 시나리오 설명**: 해당 API를 계속 사용할 경우 발생할 수 있는 잠재적 위험(예: 보안 취약점, 향후 버전 업그레이드 시 컴파일 에러, 성능 저하 등)을 시나리오로 설명해줘.
    - **라이브러리 버전 확인**: 사용 중인 프레임워크(Spring Boot 등)의 버전에 더 적합한 최신 방식이 있다면, 버전 호환성을 고려하여 점진적인 전환 방향을 제안해줘.

## 4. 버그 가능성 및 안정성 체크

시스템의 장애를 방지하고 데이터의 무결성을 지키기 위해 아래 사항을 집중 리뷰해줘.

- **잠재적 로직 결함**: `NullPointerException` 가능성, 무한 루프, 자원(Stream, DB 커넥션 등) 미반납 여부를 꼼꼼히 지적해줘.
- **트랜잭션 관리**:
    - DB 상태를 변경하는 메서드에 `@Transactional`이 적절히 설정되었는지 확인해줘.
    - **조회 전용 메서드에는 `@Transactional(readOnly = true)` 설정을 권장해줘.** (성능 최적화 및 가시성 확보)
- **동시성 및 불변성**: 멀티스레드 환경에서 공유 자원 접근 문제를 살피고, 사이드 이펙트 방지를 위해 객체의 불변성(final 사용 등)이 잘 지켜지는지 체크해줘.
- **엣지 케이스 시나리오**: 빈 값, 경계값, 데이터 부재 상황에서 단순히 "누락"이라 하지 말고, **"만약 ~한 상황(시나리오)이 발생하면 ~한 에러가 날 수 있습니다"**라고 구체적으로 설명해줘.
- **정확한 응답**: 비즈니스 예외 발생 시 의도에 맞는 HTTP Status Code(400, 404, 409 등)가 반환되는지 확인해줘.
- **성능 및 효율성**:
    - **N+1 문제**: JPA 사용 시 연관 관계 엔티티를 조회할 때 불필요한 추가 쿼리가 대량으로 발생하지 않는지 살펴줘.
    - **불필요한 DB 조회**: 반복문 내부에서 DB를 반복 호출(I/O 낭비)하지 않고, 일괄 조회(In-clause 등)를 사용하는지 확인해줘.
    - **비효율적 자료구조**: 데이터 양에 따라 적절한 Collection(List, Map, Set 등)을 선택했는지, 불필요한 객체 생성이 반복되지는 않는지 체크해줘.
    - **Lazy Loading**: 대량의 데이터를 처리할 때 한꺼번에 메모리에 올리지 않고 페이징(Paging)이나 스트림(Stream) 처리를 하는지 권장해줘.

## 5. 테스트 코드 및 검증

신뢰할 수 있는 소프트웨어를 위해 테스트 코드의 품질을 면밀히 검토해줘.

- **@DisplayName 활용**:
    - 각 테스트 메서드에 `@DisplayName`을 사용하여, 테스트가 검증하고자 하는 비즈니스 요구사항을 한글로 명확하게 기술했는지 확인해줘.
- **Given-When-Then 구조**:
    - 테스트 코드 내부가 **given, when, then** 주석으로 명확히 구분되어 있는지 확인해줘.
    - 각 단계에 맞는 로직(준비, 실행, 검증)이 적절한 주석 아래에 위치하는지 체크해줘.
- **테스트 케이스의 범위**:
    - 성공 케이스뿐만 아니라, **실패/예외 케이스**가 충분히 포함되었는지 체크해줘.
    - 경계값(Boundary Value)에 대한 테스트가 누락되지 않았는지 살펴줘.
- **검증(Assertion)의 적절성**:
    - 단순히 "에러가 나지 않음"을 확인하는 게 아니라, 실제 기대하는 값이나 상태가 정확히 반영되었는지 꼼꼼하게 검증하는지 확인해줘.
- **테스트 격리 및 독립성**:
    - 테스트 간에 의존성이 없는지, 테스트가 끝난 후 데이터가 적절히 롤백되거나 정리되는지 확인해줘.

## 6. 로깅 가이드라인

실무에서 문제 추적이 가능하도록 아래 로깅 원칙을 준수하는지 확인해줘.

- **로그 레벨 적정성**:
    - **ERROR**: 시스템 중단이나 즉각적인 조치가 필요한 장애 상황 (예: DB 연결 실패)
    - **WARN**: 즉각적인 장애는 아니지만, 운영 관점에서 주의가 필요한 상황
    - **INFO**: 운영 환경에서 추적이 필요한 **주요 비즈니스 흐름의 시작과 종료**
    - **DEBUG**: 개발 및 디버깅을 위한 상세 실행 흐름
        - **리뷰 지침**: 운영 환경(INFO 이상)에서는 이 로그가 출력되지 않음을 인지하고, **운영 추적에 꼭 필요한 정보라면 INFO 레벨로 격상**하도록 제안해줘. 반대로 불필요하게 INFO
          레벨이 남용되면 DEBUG로 내리도록 권고해줘.
- **컨텍스트 포함**: 단순히 "에러 발생"이 아니라, 어떤 `userId`, `orderId` 등 **문제의 원인이 된 파라미터**를 함께 로그에 남기는지 확인해줘.
- **에러 삼키기 금지**: `catch` 블록에서 로그만 남기고 예외를 다시 던지지 않거나 응답 처리를 하지 않아, 로직이 마치 성공한 것처럼 진행되는 코드는 반드시 지적해줘.
